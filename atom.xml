<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kitty-Wiki</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-05T12:40:55.244Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>光合新知 (北京) App组</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>测试文章</title>
    <link href="http://example.com/wiki/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <id>http://example.com/wiki/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</id>
    <published>2022-06-05T12:38:52.000Z</published>
    <updated>2022-06-05T12:40:55.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dispatch-once-为什么可以保证只执行一次？"><a href="#dispatch-once-为什么可以保证只执行一次？" class="headerlink" title="dispatch_once 为什么可以保证只执行一次？"></a>dispatch_once 为什么可以保证只执行一次？</h1><p>地址：<a href="https://shevakuilin.com/interview-dispatch_once">https://shevakuilin.com/interview-dispatch_once</a></p><p>创建时间：2020-05-08</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>想尝试写一个面试回答的系列，这是第一篇。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>GCD 中的 dispatch_once 在面试中是一个比较高频的出现的考察点，这篇文章以面试的角度来回答，为什么 dispatch_once 可以保证只执行一次。</p><p>这是一道面试真题，面试官提出了一个问题:</p><p><code>dispatch_once</code> 为什么可以保证只执行一次？</p><ol><li><code>dispatch_once_f</code> 实现原理是什么样的？</li><li><code>dispatch_once</code> 中的原子性操作是怎样的？</li><li><code>vval</code> 代表什么？ <code>DISPATCH_ONCE_DONE</code> 又表示什么？</li><li>和 <code>@synchronized</code> 的优劣分析？</li></ol><p>我们以 Q &amp; A 问答的形式来回答面试官的这个问题。</p><h2 id="为什么可以保证只执行一次"><a href="#为什么可以保证只执行一次" class="headerlink" title="为什么可以保证只执行一次"></a>为什么可以保证只执行一次</h2><p>Q: <code>dispatch_once</code>  为什么可以保证只执行一次？</p><p>A: <code>dispatch_once</code>  封装并执行了 <code>dispatch_once_f</code> 函数，其内部使用原子性操作进行标记，以此来配合信号量来决定是否唤醒其他等待的线程，而信号量则用来确保同一时间只有一个线程可以执行回调。</p><h2 id="dispatch-once-f-实现原理是什么样的？"><a href="#dispatch-once-f-实现原理是什么样的？" class="headerlink" title="dispatch_once_f 实现原理是什么样的？"></a>dispatch_once_f 实现原理是什么样的？</h2><p>为了便于理解，先放上 <code>dispatch_once_f</code> 的源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// Block 数据结构</span><br><span class="line">struct Block_layout &#123;</span><br><span class="line">    // 指向表明该block类型的类</span><br><span class="line">    void *isa;</span><br><span class="line">    // 按bit位表示一些 block 的附加信息，比如判断 block 类型、判断 block 引用计数、判断 block 是否需要执行辅助函数等</span><br><span class="line">    int flags;</span><br><span class="line">    // 保留变量</span><br><span class="line">    int reserved;</span><br><span class="line">    // 函数指针，指向具体的 block 实现的函数调用地址</span><br><span class="line">    void (*invoke)(void *, ...);</span><br><span class="line">    struct Block_descriptor *descriptor;</span><br><span class="line">    /* Imported variables. */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 宏定义</span><br><span class="line">// 触发 block 的实现</span><br><span class="line">#define _dispatch_Block_invoke(bb) \</span><br><span class="line">        ((dispatch_function_t)((struct Block_layout *)bb)-&gt;invoke)</span><br><span class="line"></span><br><span class="line">// 入口方法</span><br><span class="line">void dispatch_once(dispatch_once_t *val, dispatch_block_t block) &#123;</span><br><span class="line">    dispatch_once_f(val, block, _dispatch_Block_invoke(block));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define DISPATCH_ONCE_DONE ((struct _dispatch_once_waiter_s *)~0l)</span><br><span class="line"></span><br><span class="line">struct _dispatch_once_waiter_s &#123;</span><br><span class="line">    //链表下一个节点</span><br><span class="line">    volatile struct _dispatch_once_waiter_s *volatile dow_next;</span><br><span class="line">    // 信号量</span><br><span class="line">    _dispatch_thread_semaphore_t dow_sema;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func) &#123;</span><br><span class="line">  // volatileg 关键字编辑的变量 vval</span><br><span class="line">    // 告诉编译器此指针指向的值随时可能被其他线程改变</span><br><span class="line">    // 从而使得编译器不对此指针进行代码编译优化</span><br><span class="line">    struct _dispatch_once_waiter_s * volatile *vval =</span><br><span class="line">            (struct _dispatch_once_waiter_s**)val;</span><br><span class="line">    struct _dispatch_once_waiter_s dow = &#123; NULL, 0 &#125;;</span><br><span class="line">    struct _dispatch_once_waiter_s *tail, *tmp;</span><br><span class="line">  // 声明信号变量</span><br><span class="line">    _dispatch_thread_semaphore_t sema;</span><br><span class="line"></span><br><span class="line">    if (dispatch_atomic_cmpxchg(vval, NULL, &amp;dow, acquire)) &#123;</span><br><span class="line">        _dispatch_client_callout(ctxt, func);</span><br><span class="line"></span><br><span class="line">        dispatch_atomic_maximally_synchronizing_barrier();</span><br><span class="line">        // above assumed to contain release barrier</span><br><span class="line">        tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE, relaxed);</span><br><span class="line">        tail = &amp;dow;</span><br><span class="line">        while (tail != tmp) &#123;</span><br><span class="line">            while (!tmp-&gt;dow_next) &#123;</span><br><span class="line">                dispatch_hardware_pause();</span><br><span class="line">            &#125;</span><br><span class="line">            sema = tmp-&gt;dow_sema;</span><br><span class="line">            tmp = (struct _dispatch_once_waiter_s*)tmp-&gt;dow_next;</span><br><span class="line">            _dispatch_thread_semaphore_signal(sema);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dow.dow_sema = _dispatch_get_thread_semaphore();</span><br><span class="line">        tmp = *vval;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (tmp == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dispatch_atomic_cmpxchgvw(vval, tmp, &amp;dow, &amp;tmp, release)) &#123;</span><br><span class="line">                dow.dow_next = tmp;</span><br><span class="line">                _dispatch_thread_semaphore_wait(dow.dow_sema);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _dispatch_put_thread_semaphore(dow.dow_sema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q: <code>dispatch_once_f</code> 实现原理是什么样的？</p><p>A: 其内部定义了多个 <code>_dispatch_once_waiter_s </code> 结构体和一个 <code>_dispatch_thread_semaphore_t </code>  信号量，通过原子性操作 <code>dispatch_atomic_cmpxchg </code>  来判断标记值 <code>vval</code>  是否为 NULL (首次调用 <code>dispatch_once</code> 时，因为外部传入的 <code>dispatch_once_t</code> 变量值为 nil，所以 <code>vval</code> 会为NULL) ，如果为 NULL，则调用 <code>_dispatch_client_callout</code> 来执行回调，然后在回调执行完成之后，将 <code>vval</code> 的值更新成 <code>DISPATCH_ONCE_DONE</code> (表示任务已完成)，最后，对链表的节点进行遍历，并调用 <code>_dispatch_thread_semaphore_signal</code> 来唤醒等待中的信号量。</p><p>因为<code>dispatch_atomic_cmpxchg</code>是原子性操作，所以只有一个线程进入到该逻辑分支中，其他线程会进入另一个分支。</p><p>如果不为 NULL 或其他线程同时也调用 <code>dispatch_once</code> 时，会判断回调是否 <strong>已标记完成</strong> ，如果已完成则跳出循环；否则就是更新链表并调用 <code>_dispatch_thread_semaphore_wait</code> 阻塞线程，等待回调被标记完成后，再唤醒当前等待的线程。</p><h2 id="dispatch-once-中的原子性操作是怎样的？"><a href="#dispatch-once-中的原子性操作是怎样的？" class="headerlink" title="dispatch_once 中的原子性操作是怎样的？"></a>dispatch_once 中的原子性操作是怎样的？</h2><p>Q: <code>dispatch_once</code> 中的原子性操作是怎样的?</p><p>A: 原子性操作是 <code>dispatch_atomic_cmpxchg(vval, NULL, &amp;dow, acquire)</code> ，会将 <code>$dow</code> 赋值给 <code>vval</code> ，如果 <code>vval</code> 的初始值为NULL，返回 <code>YES</code> ,否则返回 <code>NO</code> 。以及<code>dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE)</code> 将 <code>vval</code> 修改为指定状态 <code>DISPATCH_ONCE_DONE</code>。</p><h2 id="vval-代表什么？-DISPATCH-ONCE-DONE-又表示什么？"><a href="#vval-代表什么？-DISPATCH-ONCE-DONE-又表示什么？" class="headerlink" title="vval 代表什么？ DISPATCH_ONCE_DONE 又表示什么？"></a>vval 代表什么？ DISPATCH_ONCE_DONE 又表示什么？</h2><p>Q: <code>vval</code> 代表什么？ <code>DISPATCH_ONCE_DONE</code> 又表示什么？</p><p>A: <code>vval</code> 可以理解为标记值， <code>DISPATCH_ONCE_DONE</code> 用来标记回调是否已完成，以此来决定是否要唤起信号量来解除线程的阻塞。</p><h2 id="和-synchronized-的优劣分析？"><a href="#和-synchronized-的优劣分析？" class="headerlink" title="和 @synchronized 的优劣分析？"></a>和 @synchronized 的优劣分析？</h2><p>Q: 和 <code>@synchronized</code> 的优劣分析？</p><p>A: 相比之下 <code>dispatch_once</code> 的性能更高，速度更快，并且针对处理器进行了优化。两者分别利用来不同的方式来保证线程安全， <code>@synchronized</code> 采用的是递归互斥锁的方式来保证线程安全，而 <code>dispatch_once</code> 是使用原子操作来代替锁，使用信号量来保证线程同步。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;dispatch-once-为什么可以保证只执行一次？&quot;&gt;&lt;a href=&quot;#dispatch-once-为什么可以保证只执行一次？&quot; class=&quot;headerlink&quot; title=&quot;dispatch_once 为什么可以保证只执行一次？&quot;&gt;&lt;/a&gt;dispa</summary>
      
    
    
    
    <category term="文档" scheme="http://example.com/categories/%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="测试文章" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/wiki/hello-world/"/>
    <id>http://example.com/wiki/hello-world/</id>
    <published>2022-06-05T09:53:51.790Z</published>
    <updated>2022-06-05T09:53:51.791Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
